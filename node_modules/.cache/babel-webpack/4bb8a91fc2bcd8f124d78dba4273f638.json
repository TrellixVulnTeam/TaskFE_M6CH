{"ast":null,"code":"import { Component, ViewEncapsulation, ElementRef, HostBinding, Input, ViewChild, HostListener, Pipe, EventEmitter, Output, ChangeDetectorRef, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { fromEvent } from 'rxjs';\nimport { VgStates, VgApiService, VgControlsHiddenService, VgFullscreenApiService, VgCoreModule } from '@videogular/ngx-videogular/core';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@videogular/ngx-videogular/core';\nimport * as ɵngcc2 from '@angular/common';\nconst _c0 = [\"*\"];\nconst _c1 = [\"volumeBar\"];\n\nconst _c2 = function (a0) {\n  return {\n    dragging: a0\n  };\n};\n\nfunction VgTrackSelectorComponent_option_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"option\", 4);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const track_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵproperty(\"value\", track_r1.id)(\"selected\", track_r1.selected === true);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", track_r1.label, \" \");\n  }\n}\n\nfunction VgTimeDisplayComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\");\n    ɵngcc0.ɵɵtext(1, \"LIVE\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction VgTimeDisplayComponent_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵpipe(2, \"vgUtc\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind2(2, 1, ctx_r1.getTime(), ctx_r1.vgFormat));\n  }\n}\n\nfunction VgQualitySelectorComponent_option_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"option\", 4);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const bitrate_r1 = ctx.$implicit;\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"value\", bitrate_r1.qualityIndex)(\"selected\", bitrate_r1.qualityIndex === (ctx_r0.bitrateSelected == null ? null : ctx_r0.bitrateSelected.qualityIndex));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", bitrate_r1.label, \" \");\n  }\n}\n\nfunction VgScrubBarCuePointsComponent_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 2);\n  }\n\n  if (rf & 2) {\n    const cp_r1 = ctx.$implicit;\n    ɵngcc0.ɵɵstyleProp(\"width\", cp_r1.$$style == null ? null : cp_r1.$$style.width)(\"left\", cp_r1.$$style == null ? null : cp_r1.$$style.left);\n  }\n}\n\nfunction VgScrubBarCurrentTimeComponent_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 2);\n  }\n}\n\nlet VgControlsComponent = /*#__PURE__*/(() => {\n  class VgControlsComponent {\n    // @ts-ignore\n    constructor(API, ref, hidden) {\n      this.API = API;\n      this.hidden = hidden;\n      this.isAdsPlaying = 'initial';\n      this.hideControls = false;\n      this.vgAutohide = false;\n      this.vgAutohideTime = 3;\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      this.mouseMove$ = fromEvent(this.API.videogularElement, 'mousemove');\n      this.subscriptions.push(this.mouseMove$.subscribe(this.show.bind(this)));\n      this.touchStart$ = fromEvent(this.API.videogularElement, 'touchstart');\n      this.subscriptions.push(this.touchStart$.subscribe(this.show.bind(this)));\n      this.mouseClick$ = fromEvent(this.API.videogularElement, 'click');\n      this.subscriptions.push(this.mouseClick$.subscribe(this.show.bind(this)));\n\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n      this.subscriptions.push(this.target.subscriptions.play.subscribe(this.onPlay.bind(this)));\n      this.subscriptions.push(this.target.subscriptions.pause.subscribe(this.onPause.bind(this)));\n      this.subscriptions.push(this.target.subscriptions.startAds.subscribe(this.onStartAds.bind(this)));\n      this.subscriptions.push(this.target.subscriptions.endAds.subscribe(this.onEndAds.bind(this)));\n    }\n\n    ngAfterViewInit() {\n      if (this.vgAutohide) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n\n    onPlay() {\n      if (this.vgAutohide) {\n        this.hide();\n      }\n    }\n\n    onPause() {\n      clearTimeout(this.timer);\n      this.hideControls = false;\n      this.hidden.state(false);\n    }\n\n    onStartAds() {\n      this.isAdsPlaying = 'none';\n    }\n\n    onEndAds() {\n      this.isAdsPlaying = 'initial';\n    }\n\n    hide() {\n      if (this.vgAutohide) {\n        clearTimeout(this.timer);\n        this.hideAsync();\n      }\n    }\n\n    show() {\n      clearTimeout(this.timer);\n      this.hideControls = false;\n      this.hidden.state(false);\n\n      if (this.vgAutohide) {\n        this.hideAsync();\n      }\n    }\n\n    hideAsync() {\n      if (this.API.state === VgStates.VG_PLAYING) {\n        this.timer = setTimeout(() => {\n          this.hideControls = true;\n          this.hidden.state(true);\n        }, this.vgAutohideTime * 1000);\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgControlsComponent.ɵfac = function VgControlsComponent_Factory(t) {\n    return new (t || VgControlsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgApiService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgControlsHiddenService));\n  };\n\n  VgControlsComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgControlsComponent,\n    selectors: [[\"vg-controls\"]],\n    hostVars: 4,\n    hostBindings: function VgControlsComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"pointer-events\", ctx.isAdsPlaying);\n        ɵngcc0.ɵɵclassProp(\"hide\", ctx.hideControls);\n      }\n    },\n    inputs: {\n      vgAutohide: \"vgAutohide\",\n      vgAutohideTime: \"vgAutohideTime\",\n      vgFor: \"vgFor\"\n    },\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function VgControlsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"\\n      vg-controls {\\n        position: absolute;\\n        display: flex;\\n        width: 100%;\\n        height: 50px;\\n        z-index: 300;\\n        bottom: 0;\\n        background-color: rgba(0, 0, 0, 0.5);\\n        -webkit-transition: bottom 1s;\\n        -khtml-transition: bottom 1s;\\n        -moz-transition: bottom 1s;\\n        -ms-transition: bottom 1s;\\n        transition: bottom 1s;\\n      }\\n      vg-controls.hide {\\n        bottom: -50px;\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgControlsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgVolumeComponent = /*#__PURE__*/(() => {\n  class VgVolumeComponent {\n    constructor(ref, API) {\n      this.API = API;\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n      this.isDragging = false;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n      this.ariaValue = this.getVolume() * 100;\n    }\n\n    onClick(event) {\n      this.setVolume(this.calculateVolume(event.clientX));\n    }\n\n    onMouseDown(event) {\n      this.mouseDownPosX = event.clientX;\n      this.isDragging = true;\n    }\n\n    onDrag(event) {\n      if (this.isDragging) {\n        this.setVolume(this.calculateVolume(event.clientX));\n      }\n    }\n\n    onStopDrag(event) {\n      if (this.isDragging) {\n        this.isDragging = false;\n\n        if (this.mouseDownPosX === event.clientX) {\n          this.setVolume(this.calculateVolume(event.clientX));\n        }\n      }\n    }\n\n    arrowAdjustVolume(event) {\n      if (event.keyCode === 38 || event.keyCode === 39) {\n        event.preventDefault();\n        this.setVolume(Math.max(0, Math.min(100, this.getVolume() * 100 + 10)));\n      } else if (event.keyCode === 37 || event.keyCode === 40) {\n        event.preventDefault();\n        this.setVolume(Math.max(0, Math.min(100, this.getVolume() * 100 - 10)));\n      }\n    }\n\n    calculateVolume(mousePosX) {\n      const recObj = this.volumeBarRef.nativeElement.getBoundingClientRect();\n      const volumeBarOffsetLeft = recObj.left;\n      const volumeBarWidth = recObj.width;\n      return (mousePosX - volumeBarOffsetLeft) / volumeBarWidth * 100;\n    }\n\n    setVolume(vol) {\n      this.target.volume = Math.max(0, Math.min(1, vol / 100));\n      this.ariaValue = this.target.volume * 100;\n    }\n\n    getVolume() {\n      return this.target ? this.target.volume : 0;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgVolumeComponent.ɵfac = function VgVolumeComponent_Factory(t) {\n    return new (t || VgVolumeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgApiService));\n  };\n\n  VgVolumeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgVolumeComponent,\n    selectors: [[\"vg-volume\"]],\n    viewQuery: function VgVolumeComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c1, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.volumeBarRef = _t.first);\n      }\n    },\n    hostBindings: function VgVolumeComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"mousemove\", function VgVolumeComponent_mousemove_HostBindingHandler($event) {\n          return ctx.onDrag($event);\n        }, false, ɵngcc0.ɵɵresolveDocument)(\"mouseup\", function VgVolumeComponent_mouseup_HostBindingHandler($event) {\n          return ctx.onStopDrag($event);\n        }, false, ɵngcc0.ɵɵresolveDocument)(\"keydown\", function VgVolumeComponent_keydown_HostBindingHandler($event) {\n          return ctx.arrowAdjustVolume($event);\n        });\n      }\n    },\n    inputs: {\n      vgFor: \"vgFor\"\n    },\n    decls: 5,\n    vars: 9,\n    consts: [[\"tabindex\", \"0\", \"role\", \"slider\", \"aria-label\", \"volume level\", \"aria-level\", \"polite\", \"aria-valuemin\", \"0\", \"aria-valuemax\", \"100\", \"aria-orientation\", \"horizontal\", 1, \"volumeBar\", 3, \"click\", \"mousedown\"], [\"volumeBar\", \"\"], [1, \"volumeBackground\", 3, \"ngClass\"], [1, \"volumeValue\"], [1, \"volumeKnob\"]],\n    template: function VgVolumeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\n        ɵngcc0.ɵɵlistener(\"click\", function VgVolumeComponent_Template_div_click_0_listener($event) {\n          return ctx.onClick($event);\n        })(\"mousedown\", function VgVolumeComponent_Template_div_mousedown_0_listener($event) {\n          return ctx.onMouseDown($event);\n        });\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n        ɵngcc0.ɵɵelement(3, \"div\", 3);\n        ɵngcc0.ɵɵelement(4, \"div\", 4);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-valuenow\", ctx.ariaValue)(\"aria-valuetext\", ctx.ariaValue + \"%\");\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(7, _c2, ctx.isDragging));\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵstyleProp(\"width\", ctx.getVolume() * (100 - 15) + \"%\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵstyleProp(\"left\", ctx.getVolume() * (100 - 15) + \"%\");\n      }\n    },\n    directives: [ɵngcc2.NgClass],\n    styles: [\"\\n      vg-volume {\\n        -webkit-touch-callout: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        display: flex;\\n        justify-content: center;\\n        height: 50px;\\n        width: 100px;\\n        cursor: pointer;\\n        color: white;\\n        line-height: 50px;\\n      }\\n      vg-volume .volumeBar {\\n        position: relative;\\n        display: flex;\\n        flex-grow: 1;\\n        align-items: center;\\n      }\\n      vg-volume .volumeBackground {\\n        display: flex;\\n        flex-grow: 1;\\n        height: 5px;\\n        pointer-events: none;\\n        background-color: #333;\\n      }\\n      vg-volume .volumeValue {\\n        display: flex;\\n        height: 5px;\\n        pointer-events: none;\\n        background-color: #fff;\\n        transition: all 0.2s ease-out;\\n      }\\n      vg-volume .volumeKnob {\\n        position: absolute;\\n        width: 15px;\\n        height: 15px;\\n        left: 0;\\n        top: 50%;\\n        transform: translateY(-50%);\\n        border-radius: 15px;\\n        pointer-events: none;\\n        background-color: #fff;\\n        transition: all 0.2s ease-out;\\n      }\\n      vg-volume .volumeBackground.dragging .volumeValue,\\n      vg-volume .volumeBackground.dragging .volumeKnob {\\n        transition: none;\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgVolumeComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgTrackSelectorComponent = /*#__PURE__*/(() => {\n  class VgTrackSelectorComponent {\n    constructor(ref, API) {\n      this.API = API;\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n      const subs = Array.from(this.API.getMasterMedia().elem.children).filter(item => item.tagName === 'TRACK').filter(item => item.kind === 'subtitles').map(item => ({\n        label: item.label,\n        selected: item.default === true,\n        id: item.srclang\n      }));\n      this.tracks = [...subs, {\n        id: null,\n        label: 'Off',\n        selected: subs.every(item => item.selected === false)\n      }];\n      const track = this.tracks.filter(item => item.selected === true)[0];\n      this.trackSelected = track.id;\n      this.ariaValue = track.label;\n    }\n\n    selectTrack(trackId) {\n      this.trackSelected = trackId === 'null' ? null : trackId;\n      this.ariaValue = 'No track selected';\n      Array.from(this.API.getMasterMedia().elem.textTracks).forEach(item => {\n        if (item.language === trackId) {\n          this.ariaValue = item.label;\n          item.mode = 'showing';\n        } else {\n          item.mode = 'hidden';\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgTrackSelectorComponent.ɵfac = function VgTrackSelectorComponent_Factory(t) {\n    return new (t || VgTrackSelectorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgApiService));\n  };\n\n  VgTrackSelectorComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgTrackSelectorComponent,\n    selectors: [[\"vg-track-selector\"]],\n    inputs: {\n      vgFor: \"vgFor\"\n    },\n    decls: 5,\n    vars: 5,\n    consts: [[1, \"container\"], [1, \"track-selected\"], [\"tabindex\", \"0\", \"aria-label\", \"track selector\", 1, \"trackSelector\", 3, \"change\"], [3, \"value\", \"selected\", 4, \"ngFor\", \"ngForOf\"], [3, \"value\", \"selected\"]],\n    template: function VgTrackSelectorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n        ɵngcc0.ɵɵtext(2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(3, \"select\", 2);\n        ɵngcc0.ɵɵlistener(\"change\", function VgTrackSelectorComponent_Template_select_change_3_listener($event) {\n          return ctx.selectTrack($event.target.value);\n        });\n        ɵngcc0.ɵɵtemplate(4, VgTrackSelectorComponent_option_4_Template, 2, 3, \"option\", 3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵclassProp(\"vg-icon-closed_caption\", !ctx.trackSelected);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵtextInterpolate1(\" \", ctx.trackSelected || \"\", \" \");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵattribute(\"aria-valuetext\", ctx.ariaValue);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.tracks);\n      }\n    },\n    directives: [ɵngcc2.NgForOf],\n    styles: [\"\\n      vg-track-selector {\\n        -webkit-touch-callout: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        display: flex;\\n        justify-content: center;\\n        width: 50px;\\n        height: 50px;\\n        cursor: pointer;\\n        color: white;\\n        line-height: 50px;\\n      }\\n      vg-track-selector .container {\\n        position: relative;\\n        display: flex;\\n        flex-grow: 1;\\n        align-items: center;\\n        padding: 0;\\n        margin: 5px;\\n      }\\n      vg-track-selector select.trackSelector {\\n        width: 50px;\\n        padding: 5px 8px;\\n        border: none;\\n        background: none;\\n        -webkit-appearance: none;\\n        -moz-appearance: none;\\n        appearance: none;\\n        color: transparent;\\n        font-size: 16px;\\n      }\\n      vg-track-selector select.trackSelector::-ms-expand {\\n        display: none;\\n      }\\n      vg-track-selector select.trackSelector option {\\n        color: #000;\\n      }\\n      vg-track-selector .track-selected {\\n        position: absolute;\\n        width: 100%;\\n        height: 50px;\\n        top: -6px;\\n        text-align: center;\\n        text-transform: uppercase;\\n        font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\\n        padding-top: 2px;\\n        pointer-events: none;\\n      }\\n      vg-track-selector .vg-icon-closed_caption:before {\\n        width: 100%;\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgTrackSelectorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // Workaround until we can use UTC with Angular Date Pipe\n\n\nlet VgUtcPipe = /*#__PURE__*/(() => {\n  class VgUtcPipe {\n    transform(value, format) {\n      let date = new Date(value);\n      let result = format;\n      let ss = date.getUTCSeconds();\n      let mm = date.getUTCMinutes();\n      let hh = date.getUTCHours();\n\n      if (ss < 10) {\n        ss = '0' + ss;\n      }\n\n      if (mm < 10) {\n        mm = '0' + mm;\n      }\n\n      if (hh < 10) {\n        hh = '0' + hh;\n      }\n\n      result = result.replace(/ss/g, ss);\n      result = result.replace(/mm/g, mm);\n      result = result.replace(/hh/g, hh);\n      return result;\n    }\n\n  }\n\n  VgUtcPipe.ɵfac = function VgUtcPipe_Factory(t) {\n    return new (t || VgUtcPipe)();\n  };\n\n  VgUtcPipe.ɵpipe = /*@__PURE__*/ɵngcc0.ɵɵdefinePipe({\n    name: \"vgUtc\",\n    type: VgUtcPipe,\n    pure: true\n  });\n  return VgUtcPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgTimeDisplayComponent = /*#__PURE__*/(() => {\n  class VgTimeDisplayComponent {\n    constructor(ref, API) {\n      this.API = API;\n      this.vgProperty = 'current';\n      this.vgFormat = 'mm:ss';\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    getTime() {\n      let t = 0;\n\n      if (this.target) {\n        t = Math.round(this.target.time[this.vgProperty]);\n        t = isNaN(t) || this.target.isLive ? 0 : t;\n      }\n\n      return t;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgTimeDisplayComponent.ɵfac = function VgTimeDisplayComponent_Factory(t) {\n    return new (t || VgTimeDisplayComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgApiService));\n  };\n\n  VgTimeDisplayComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgTimeDisplayComponent,\n    selectors: [[\"vg-time-display\"]],\n    inputs: {\n      vgProperty: \"vgProperty\",\n      vgFormat: \"vgFormat\",\n      vgFor: \"vgFor\"\n    },\n    ngContentSelectors: _c0,\n    decls: 3,\n    vars: 2,\n    consts: [[4, \"ngIf\"]],\n    template: function VgTimeDisplayComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, VgTimeDisplayComponent_span_0_Template, 2, 0, \"span\", 0);\n        ɵngcc0.ɵɵtemplate(1, VgTimeDisplayComponent_span_1_Template, 3, 4, \"span\", 0);\n        ɵngcc0.ɵɵprojection(2);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.target == null ? null : ctx.target.isLive);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !(ctx.target == null ? null : ctx.target.isLive));\n      }\n    },\n    directives: [ɵngcc2.NgIf],\n    pipes: [VgUtcPipe],\n    styles: [\"\\n      vg-time-display {\\n        -webkit-touch-callout: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        display: flex;\\n        justify-content: center;\\n        height: 50px;\\n        width: 60px;\\n        cursor: pointer;\\n        color: white;\\n        line-height: 50px;\\n        pointer-events: none;\\n        font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgTimeDisplayComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgScrubBarComponent = /*#__PURE__*/(() => {\n  class VgScrubBarComponent {\n    constructor(ref, API, vgControlsHiddenState) {\n      this.API = API;\n      this.hideScrubBar = false;\n      this.vgSlider = true;\n      this.isSeeking = false;\n      this.wasPlaying = false;\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n      this.subscriptions.push(vgControlsHiddenState.isHidden.subscribe(hide => this.onHideScrubBar(hide)));\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    seekStart() {\n      if (this.target.canPlay) {\n        this.isSeeking = true;\n\n        if (this.target.state === VgStates.VG_PLAYING) {\n          this.wasPlaying = true;\n        }\n\n        this.target.pause();\n      }\n    }\n\n    seekMove(offset) {\n      if (this.isSeeking) {\n        const percentage = Math.max(Math.min(offset * 100 / this.elem.scrollWidth, 99.9), 0);\n        this.target.time.current = percentage * this.target.time.total / 100;\n        this.target.seekTime(percentage, true);\n      }\n    }\n\n    seekEnd(offset) {\n      this.isSeeking = false;\n\n      if (this.target.canPlay) {\n        const percentage = Math.max(Math.min(offset * 100 / this.elem.scrollWidth, 99.9), 0);\n        this.target.seekTime(percentage, true);\n\n        if (this.wasPlaying) {\n          this.wasPlaying = false;\n          this.target.play();\n        }\n      }\n    }\n\n    touchEnd() {\n      this.isSeeking = false;\n\n      if (this.wasPlaying) {\n        this.wasPlaying = false;\n        this.target.play();\n      }\n    }\n\n    getTouchOffset(event) {\n      let offsetLeft = 0;\n      let element = event.target;\n\n      while (element) {\n        offsetLeft += element.offsetLeft;\n        element = element.offsetParent;\n      }\n\n      return event.touches[0].pageX - offsetLeft;\n    }\n\n    onMouseDownScrubBar($event) {\n      if (this.target) {\n        if (!this.target.isLive) {\n          if (!this.vgSlider) {\n            this.seekEnd($event.offsetX);\n          } else {\n            this.seekStart();\n          }\n        }\n      }\n    }\n\n    onMouseMoveScrubBar($event) {\n      if (this.target) {\n        if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n          this.seekMove($event.offsetX);\n        }\n      }\n    }\n\n    onMouseUpScrubBar($event) {\n      if (this.target) {\n        if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n          this.seekEnd($event.offsetX);\n        }\n      }\n    }\n\n    onTouchStartScrubBar($event) {\n      if (this.target) {\n        if (!this.target.isLive) {\n          if (!this.vgSlider) {\n            this.seekEnd(this.getTouchOffset($event));\n          } else {\n            this.seekStart();\n          }\n        }\n      }\n    }\n\n    onTouchMoveScrubBar($event) {\n      if (this.target) {\n        if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n          this.seekMove(this.getTouchOffset($event));\n        }\n      }\n    } // @ts-ignore\n\n\n    onTouchCancelScrubBar(_$event) {\n      if (this.target) {\n        if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n          this.touchEnd();\n        }\n      }\n    } // @ts-ignore\n\n\n    onTouchEndScrubBar(_$event) {\n      if (this.target) {\n        if (!this.target.isLive && this.vgSlider && this.isSeeking) {\n          this.touchEnd();\n        }\n      }\n    }\n\n    arrowAdjustVolume(event) {\n      if (this.target) {\n        if (event.keyCode === 38 || event.keyCode === 39) {\n          event.preventDefault();\n          this.target.seekTime((this.target.time.current + 5000) / 1000, false);\n        } else if (event.keyCode === 37 || event.keyCode === 40) {\n          event.preventDefault();\n          this.target.seekTime((this.target.time.current - 5000) / 1000, false);\n        }\n      }\n    }\n\n    getPercentage() {\n      return this.target ? Math.round(this.target.time.current * 100 / this.target.time.total) + '%' : '0%';\n    }\n\n    onHideScrubBar(hide) {\n      this.hideScrubBar = hide;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgScrubBarComponent.ɵfac = function VgScrubBarComponent_Factory(t) {\n    return new (t || VgScrubBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgApiService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgControlsHiddenService));\n  };\n\n  VgScrubBarComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgScrubBarComponent,\n    selectors: [[\"vg-scrub-bar\"]],\n    hostVars: 2,\n    hostBindings: function VgScrubBarComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"mousedown\", function VgScrubBarComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onMouseDownScrubBar($event);\n        })(\"mousemove\", function VgScrubBarComponent_mousemove_HostBindingHandler($event) {\n          return ctx.onMouseMoveScrubBar($event);\n        }, false, ɵngcc0.ɵɵresolveDocument)(\"mouseup\", function VgScrubBarComponent_mouseup_HostBindingHandler($event) {\n          return ctx.onMouseUpScrubBar($event);\n        }, false, ɵngcc0.ɵɵresolveDocument)(\"touchstart\", function VgScrubBarComponent_touchstart_HostBindingHandler($event) {\n          return ctx.onTouchStartScrubBar($event);\n        })(\"touchmove\", function VgScrubBarComponent_touchmove_HostBindingHandler($event) {\n          return ctx.onTouchMoveScrubBar($event);\n        }, false, ɵngcc0.ɵɵresolveDocument)(\"touchcancel\", function VgScrubBarComponent_touchcancel_HostBindingHandler($event) {\n          return ctx.onTouchCancelScrubBar($event);\n        }, false, ɵngcc0.ɵɵresolveDocument)(\"touchend\", function VgScrubBarComponent_touchend_HostBindingHandler($event) {\n          return ctx.onTouchEndScrubBar($event);\n        }, false, ɵngcc0.ɵɵresolveDocument)(\"keydown\", function VgScrubBarComponent_keydown_HostBindingHandler($event) {\n          return ctx.arrowAdjustVolume($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"hide\", ctx.hideScrubBar);\n      }\n    },\n    inputs: {\n      vgSlider: \"vgSlider\",\n      vgFor: \"vgFor\"\n    },\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 2,\n    consts: [[\"tabindex\", \"0\", \"role\", \"slider\", \"aria-label\", \"scrub bar\", \"aria-level\", \"polite\", \"aria-valuemin\", \"0\", \"aria-valuemax\", \"100\", 1, \"scrubBar\"]],\n    template: function VgScrubBarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-valuenow\", ctx.getPercentage())(\"aria-valuetext\", ctx.getPercentage());\n      }\n    },\n    styles: [\"\\n      vg-scrub-bar {\\n        -webkit-touch-callout: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        position: absolute;\\n        width: 100%;\\n        height: 5px;\\n        bottom: 50px;\\n        margin: 0;\\n        cursor: pointer;\\n        align-items: center;\\n        background: rgba(0, 0, 0, 0.75);\\n        z-index: 250;\\n        -webkit-transition: bottom 1s, opacity 0.5s;\\n        -khtml-transition: bottom 1s, opacity 0.5s;\\n        -moz-transition: bottom 1s, opacity 0.5s;\\n        -ms-transition: bottom 1s, opacity 0.5s;\\n        transition: bottom 1s, opacity 0.5s;\\n      }\\n      vg-scrub-bar .scrubBar {\\n        position: relative;\\n        display: flex;\\n        flex-grow: 1;\\n        align-items: center;\\n        height: 100%;\\n      }\\n      vg-controls vg-scrub-bar {\\n        position: relative;\\n        bottom: 0;\\n        background: transparent;\\n        height: 50px;\\n        flex-grow: 1;\\n        flex-basis: 0;\\n        margin: 0 10px;\\n        -webkit-transition: initial;\\n        -khtml-transition: initial;\\n        -moz-transition: initial;\\n        -ms-transition: initial;\\n        transition: initial;\\n      }\\n      vg-scrub-bar.hide {\\n        bottom: 0;\\n        opacity: 0;\\n      }\\n      vg-controls vg-scrub-bar.hide {\\n        bottom: initial;\\n        opacity: initial;\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgScrubBarComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgQualitySelectorComponent = /*#__PURE__*/(() => {\n  class VgQualitySelectorComponent {\n    constructor(ref, API) {\n      this.API = API;\n      this.onBitrateChange = new EventEmitter();\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {}\n\n    ngOnChanges(changes) {\n      if (changes.bitrates.currentValue && changes.bitrates.currentValue.length) {\n        this.bitrates.forEach(item => item.label = item.label || Math.round(item.bitrate / 1000).toString());\n      }\n    }\n\n    selectBitrate(index) {\n      this.bitrateSelected = this.bitrates[index];\n      this.onBitrateChange.emit(this.bitrates[index]);\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgQualitySelectorComponent.ɵfac = function VgQualitySelectorComponent_Factory(t) {\n    return new (t || VgQualitySelectorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgApiService));\n  };\n\n  VgQualitySelectorComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgQualitySelectorComponent,\n    selectors: [[\"vg-quality-selector\"]],\n    inputs: {\n      bitrates: \"bitrates\"\n    },\n    outputs: {\n      onBitrateChange: \"onBitrateChange\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 5,\n    vars: 5,\n    consts: [[1, \"container\"], [1, \"quality-selected\"], [\"tabindex\", \"0\", \"aria-label\", \"quality selector\", 1, \"quality-selector\", 3, \"change\"], [3, \"value\", \"selected\", 4, \"ngFor\", \"ngForOf\"], [3, \"value\", \"selected\"]],\n    template: function VgQualitySelectorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 1);\n        ɵngcc0.ɵɵtext(2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(3, \"select\", 2);\n        ɵngcc0.ɵɵlistener(\"change\", function VgQualitySelectorComponent_Template_select_change_3_listener($event) {\n          return ctx.selectBitrate($event.target.value);\n        });\n        ɵngcc0.ɵɵtemplate(4, VgQualitySelectorComponent_option_4_Template, 2, 3, \"option\", 3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵclassProp(\"vg-icon-hd\", !ctx.bitrateSelected);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵtextInterpolate1(\" \", ctx.bitrateSelected == null ? null : ctx.bitrateSelected.label, \" \");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵattribute(\"aria-valuetext\", ctx.ariaValue);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.bitrates);\n      }\n    },\n    directives: [ɵngcc2.NgForOf],\n    styles: [\"\\n      vg-quality-selector {\\n        -webkit-touch-callout: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        display: flex;\\n        justify-content: center;\\n        width: 50px;\\n        height: 50px;\\n        cursor: pointer;\\n        color: white;\\n        line-height: 50px;\\n      }\\n      vg-quality-selector .container {\\n        position: relative;\\n        display: flex;\\n        flex-grow: 1;\\n        align-items: center;\\n        padding: 0;\\n        margin: 5px;\\n      }\\n      vg-quality-selector select.quality-selector {\\n        width: 50px;\\n        padding: 5px 8px;\\n        border: none;\\n        background: none;\\n        -webkit-appearance: none;\\n        -moz-appearance: none;\\n        appearance: none;\\n        color: transparent;\\n        font-size: 16px;\\n      }\\n      vg-quality-selector select.quality-selector::-ms-expand {\\n        display: none;\\n      }\\n      vg-quality-selector select.quality-selector option {\\n        color: #000;\\n      }\\n      vg-quality-selector .quality-selected {\\n        position: absolute;\\n        width: 100%;\\n        height: 50px;\\n        top: -6px;\\n        text-align: center;\\n        text-transform: uppercase;\\n        font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\\n        padding-top: 2px;\\n        pointer-events: none;\\n      }\\n      vg-quality-selector .vg-icon-closed_caption:before {\\n        width: 100%;\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgQualitySelectorComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgPlaybackButtonComponent = /*#__PURE__*/(() => {\n  class VgPlaybackButtonComponent {\n    constructor(ref, API, cdr) {\n      this.API = API;\n      this.cdr = cdr;\n      this.subscriptions = [];\n      this.ariaValue = 1;\n      this.elem = ref.nativeElement;\n      this.playbackValues = ['0.5', '1.0', '1.5', '2.0'];\n      this.playbackIndex = 1;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    onClick() {\n      this.updatePlaybackSpeed();\n    }\n\n    onKeyDown(event) {\n      // On press Enter (13) or Space (32)\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault();\n        this.updatePlaybackSpeed();\n      }\n    }\n\n    updatePlaybackSpeed() {\n      this.playbackIndex = ++this.playbackIndex % this.playbackValues.length;\n\n      if (this.target instanceof VgApiService) {\n        this.target.playbackRate = this.playbackValues[this.playbackIndex];\n      } else {\n        this.target.playbackRate[this.vgFor] = this.playbackValues[this.playbackIndex];\n      }\n\n      this.detectChanges();\n    }\n\n    getPlaybackRate() {\n      this.ariaValue = this.target ? this.target.playbackRate : 1.0;\n      return this.ariaValue;\n    }\n\n    detectChanges() {\n      try {\n        this.cdr.detectChanges();\n      } catch (e) {\n        console.warn(e);\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgPlaybackButtonComponent.ɵfac = function VgPlaybackButtonComponent_Factory(t) {\n    return new (t || VgPlaybackButtonComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgApiService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  VgPlaybackButtonComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgPlaybackButtonComponent,\n    selectors: [[\"vg-playback-button\"]],\n    hostBindings: function VgPlaybackButtonComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function VgPlaybackButtonComponent_click_HostBindingHandler() {\n          return ctx.onClick();\n        })(\"keydown\", function VgPlaybackButtonComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n    },\n    inputs: {\n      playbackValues: \"playbackValues\",\n      vgFor: \"vgFor\"\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[\"tabindex\", \"0\", \"role\", \"button\", \"aria-label\", \"playback speed button\", 1, \"button\"]],\n    template: function VgPlaybackButtonComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"span\", 0);\n        ɵngcc0.ɵɵtext(1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"aria-valuetext\", ctx.ariaValue);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵtextInterpolate1(\" \", ctx.getPlaybackRate(), \"x \");\n      }\n    },\n    styles: [\"\\n      vg-playback-button {\\n        -webkit-touch-callout: none;\\n        -webkit-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        display: flex;\\n        justify-content: center;\\n        height: 50px;\\n        width: 50px;\\n        cursor: pointer;\\n        color: white;\\n        line-height: 50px;\\n        font-family: Helvetica Neue, Helvetica, Arial, sans-serif;\\n      }\\n      vg-playback-button .button {\\n        display: flex;\\n        align-items: center;\\n        justify-content: center;\\n        width: 50px;\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgPlaybackButtonComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgPlayPauseComponent = /*#__PURE__*/(() => {\n  class VgPlayPauseComponent {\n    constructor(ref, API) {\n      this.API = API;\n      this.subscriptions = [];\n      this.ariaValue = VgStates.VG_PAUSED;\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    onClick() {\n      this.playPause();\n    }\n\n    onKeyDown(event) {\n      // On press Enter (13) or Space (32)\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault();\n        this.playPause();\n      }\n    }\n\n    playPause() {\n      const state = this.getState();\n\n      switch (state) {\n        case VgStates.VG_PLAYING:\n          this.target.pause();\n          break;\n\n        case VgStates.VG_PAUSED:\n        case VgStates.VG_ENDED:\n          this.target.play();\n          break;\n      }\n    }\n\n    getState() {\n      this.ariaValue = this.target ? this.target.state : VgStates.VG_PAUSED;\n      return this.ariaValue;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgPlayPauseComponent.ɵfac = function VgPlayPauseComponent_Factory(t) {\n    return new (t || VgPlayPauseComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgApiService));\n  };\n\n  VgPlayPauseComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgPlayPauseComponent,\n    selectors: [[\"vg-play-pause\"]],\n    hostBindings: function VgPlayPauseComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function VgPlayPauseComponent_click_HostBindingHandler() {\n          return ctx.onClick();\n        })(\"keydown\", function VgPlayPauseComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n    },\n    inputs: {\n      vgFor: \"vgFor\"\n    },\n    decls: 1,\n    vars: 6,\n    consts: [[\"tabindex\", \"0\", \"role\", \"button\", 1, \"icon\"]],\n    template: function VgPlayPauseComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"vg-icon-pause\", ctx.getState() === \"playing\")(\"vg-icon-play_arrow\", ctx.getState() === \"paused\" || ctx.getState() === \"ended\");\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.getState() === \"paused\" ? \"play\" : \"pause\")(\"aria-valuetext\", ctx.ariaValue);\n      }\n    },\n    styles: [\"\\n      vg-play-pause {\\n        -webkit-touch-callout: none;\\n        -webkit-user-select: none;\\n        -khtml-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        display: flex;\\n        justify-content: center;\\n        height: 50px;\\n        width: 50px;\\n        cursor: pointer;\\n        color: white;\\n        line-height: 50px;\\n      }\\n      vg-play-pause .icon {\\n        pointer-events: none;\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgPlayPauseComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgMuteComponent = /*#__PURE__*/(() => {\n  class VgMuteComponent {\n    constructor(ref, API) {\n      this.API = API;\n      this.subscriptions = [];\n      this.ariaValue = 'unmuted';\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n      this.currentVolume = this.target.volume;\n    }\n\n    onClick() {\n      this.changeMuteState();\n    }\n\n    onKeyDown(event) {\n      // On press Enter (13) or Space (32)\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault();\n        this.changeMuteState();\n      }\n    }\n\n    changeMuteState() {\n      const volume = this.getVolume();\n\n      if (volume === 0) {\n        if (this.target.volume === 0 && this.currentVolume === 0) {\n          this.currentVolume = 1;\n        }\n\n        this.target.volume = this.currentVolume;\n      } else {\n        this.currentVolume = volume;\n        this.target.volume = 0;\n      }\n    }\n\n    getVolume() {\n      const volume = this.target ? this.target.volume : 0;\n      this.ariaValue = volume ? 'unmuted' : 'muted';\n      return volume;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgMuteComponent.ɵfac = function VgMuteComponent_Factory(t) {\n    return new (t || VgMuteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgApiService));\n  };\n\n  VgMuteComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgMuteComponent,\n    selectors: [[\"vg-mute\"]],\n    hostBindings: function VgMuteComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function VgMuteComponent_click_HostBindingHandler() {\n          return ctx.onClick();\n        })(\"keydown\", function VgMuteComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n    },\n    inputs: {\n      vgFor: \"vgFor\"\n    },\n    decls: 1,\n    vars: 9,\n    consts: [[\"tabindex\", \"0\", \"role\", \"button\", \"aria-label\", \"mute button\", 1, \"icon\"]],\n    template: function VgMuteComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"vg-icon-volume_up\", ctx.getVolume() >= 0.75)(\"vg-icon-volume_down\", ctx.getVolume() >= 0.25 && ctx.getVolume() < 0.75)(\"vg-icon-volume_mute\", ctx.getVolume() > 0 && ctx.getVolume() < 0.25)(\"vg-icon-volume_off\", ctx.getVolume() === 0);\n        ɵngcc0.ɵɵattribute(\"aria-valuetext\", ctx.ariaValue);\n      }\n    },\n    styles: [\"\\n      vg-mute {\\n        -webkit-touch-callout: none;\\n        -webkit-user-select: none;\\n        -khtml-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        display: flex;\\n        justify-content: center;\\n        height: 50px;\\n        width: 50px;\\n        cursor: pointer;\\n        color: white;\\n        line-height: 50px;\\n      }\\n      vg-mute .icon {\\n        pointer-events: none;\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgMuteComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgFullscreenComponent = /*#__PURE__*/(() => {\n  class VgFullscreenComponent {\n    constructor(ref, API, fsAPI) {\n      this.API = API;\n      this.fsAPI = fsAPI;\n      this.isFullscreen = false;\n      this.subscriptions = [];\n      this.ariaValue = 'normal mode';\n      this.elem = ref.nativeElement;\n      this.subscriptions.push(this.fsAPI.onChangeFullscreen.subscribe(this.onChangeFullscreen.bind(this)));\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    onChangeFullscreen(fsState) {\n      this.ariaValue = fsState ? 'fullscreen mode' : 'normal mode';\n      this.isFullscreen = fsState;\n    }\n\n    onClick() {\n      this.changeFullscreenState();\n    }\n\n    onKeyDown(event) {\n      // On press Enter (13) or Space (32)\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault();\n        this.changeFullscreenState();\n      }\n    }\n\n    changeFullscreenState() {\n      let element = this.target;\n\n      if (this.target instanceof VgApiService) {\n        element = null;\n      }\n\n      this.fsAPI.toggleFullscreen(element);\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgFullscreenComponent.ɵfac = function VgFullscreenComponent_Factory(t) {\n    return new (t || VgFullscreenComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgApiService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgFullscreenApiService));\n  };\n\n  VgFullscreenComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgFullscreenComponent,\n    selectors: [[\"vg-fullscreen\"]],\n    hostBindings: function VgFullscreenComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function VgFullscreenComponent_click_HostBindingHandler() {\n          return ctx.onClick();\n        })(\"keydown\", function VgFullscreenComponent_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        });\n      }\n    },\n    decls: 1,\n    vars: 5,\n    consts: [[\"tabindex\", \"0\", \"role\", \"button\", \"aria-label\", \"fullscreen button\", 1, \"icon\"]],\n    template: function VgFullscreenComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"vg-icon-fullscreen\", !ctx.isFullscreen)(\"vg-icon-fullscreen_exit\", ctx.isFullscreen);\n        ɵngcc0.ɵɵattribute(\"aria-valuetext\", ctx.ariaValue);\n      }\n    },\n    styles: [\"\\n      vg-fullscreen {\\n        -webkit-touch-callout: none;\\n        -webkit-user-select: none;\\n        -khtml-user-select: none;\\n        -moz-user-select: none;\\n        -ms-user-select: none;\\n        user-select: none;\\n        display: flex;\\n        justify-content: center;\\n        height: 50px;\\n        width: 50px;\\n        cursor: pointer;\\n        color: white;\\n        line-height: 50px;\\n      }\\n      vg-fullscreen .icon {\\n        pointer-events: none;\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgFullscreenComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgScrubBarBufferingTimeComponent = /*#__PURE__*/(() => {\n  class VgScrubBarBufferingTimeComponent {\n    constructor(ref, API) {\n      this.API = API;\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    getBufferTime() {\n      let bufferTime = '0%';\n\n      if (this.target && this.target.buffer && this.target.buffered.length) {\n        if (this.target.time.total === 0) {\n          bufferTime = '0%';\n        } else {\n          bufferTime = this.target.buffer.end / this.target.time.total * 100 + '%';\n        }\n      }\n\n      return bufferTime;\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgScrubBarBufferingTimeComponent.ɵfac = function VgScrubBarBufferingTimeComponent_Factory(t) {\n    return new (t || VgScrubBarBufferingTimeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgApiService));\n  };\n\n  VgScrubBarBufferingTimeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgScrubBarBufferingTimeComponent,\n    selectors: [[\"vg-scrub-bar-buffering-time\"]],\n    inputs: {\n      vgFor: \"vgFor\"\n    },\n    decls: 1,\n    vars: 2,\n    consts: [[1, \"background\"]],\n    template: function VgScrubBarBufferingTimeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"width\", ctx.getBufferTime());\n      }\n    },\n    styles: [\"\\n      vg-scrub-bar-buffering-time {\\n        display: flex;\\n        width: 100%;\\n        height: 5px;\\n        pointer-events: none;\\n        position: absolute;\\n      }\\n      vg-scrub-bar-buffering-time .background {\\n        background-color: rgba(255, 255, 255, 0.3);\\n      }\\n      vg-controls vg-scrub-bar-buffering-time {\\n        position: absolute;\\n        top: calc(50% - 3px);\\n      }\\n      vg-controls vg-scrub-bar-buffering-time .background {\\n        -webkit-border-radius: 2px;\\n        -moz-border-radius: 2px;\\n        border-radius: 2px;\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgScrubBarBufferingTimeComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable-next-line: no-conflicting-lifecycle\n\n\nlet VgScrubBarCuePointsComponent = /*#__PURE__*/(() => {\n  class VgScrubBarCuePointsComponent {\n    constructor(ref, API) {\n      this.API = API;\n      this.onLoadedMetadataCalled = false;\n      this.cuePoints = [];\n      this.subscriptions = [];\n      this.totalCues = 0;\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n      const onTimeUpdate = this.target.subscriptions.loadedMetadata;\n      this.subscriptions.push(onTimeUpdate.subscribe(this.onLoadedMetadata.bind(this)));\n\n      if (this.onLoadedMetadataCalled) {\n        this.onLoadedMetadata();\n      }\n    }\n\n    onLoadedMetadata() {\n      if (this.vgCuePoints) {\n        // We need to transform the TextTrackCueList to Array or it doesn't work on IE11/Edge.\n        // See: https://github.com/videogular/videogular2/issues/369\n        this.cuePoints = [];\n\n        for (let i = 0, l = this.vgCuePoints.length; i < l; i++) {\n          const end = this.vgCuePoints[i].endTime >= 0 ? this.vgCuePoints[i].endTime : this.vgCuePoints[i].startTime + 1;\n          const cuePointDuration = (end - this.vgCuePoints[i].startTime) * 1000;\n          let position = '0';\n          let percentWidth = '0';\n\n          if (typeof cuePointDuration === 'number' && this.target.time.total) {\n            percentWidth = cuePointDuration * 100 / this.target.time.total + '%';\n            position = this.vgCuePoints[i].startTime * 100 / Math.round(this.target.time.total / 1000) + '%';\n          }\n\n          this.vgCuePoints[i].$$style = {\n            width: percentWidth,\n            left: position\n          };\n          this.cuePoints.push(this.vgCuePoints[i]);\n        }\n      }\n    }\n\n    updateCuePoints() {\n      if (!this.target) {\n        this.onLoadedMetadataCalled = true;\n        return;\n      }\n\n      this.onLoadedMetadata();\n    }\n\n    ngOnChanges(changes) {\n      if (changes.vgCuePoints.currentValue) {\n        this.updateCuePoints();\n      }\n    }\n\n    ngDoCheck() {\n      if (this.vgCuePoints) {\n        const changes = this.totalCues !== this.vgCuePoints.length;\n\n        if (changes) {\n          this.totalCues = this.vgCuePoints.length;\n          this.updateCuePoints();\n        }\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgScrubBarCuePointsComponent.ɵfac = function VgScrubBarCuePointsComponent_Factory(t) {\n    return new (t || VgScrubBarCuePointsComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgApiService));\n  };\n\n  VgScrubBarCuePointsComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgScrubBarCuePointsComponent,\n    selectors: [[\"vg-scrub-bar-cue-points\"]],\n    inputs: {\n      vgCuePoints: \"vgCuePoints\",\n      vgFor: \"vgFor\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 2,\n    vars: 1,\n    consts: [[1, \"cue-point-container\"], [\"class\", \"cue-point\", 3, \"width\", \"left\", 4, \"ngFor\", \"ngForOf\"], [1, \"cue-point\"]],\n    template: function VgScrubBarCuePointsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵtemplate(1, VgScrubBarCuePointsComponent_span_1_Template, 1, 4, \"span\", 1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.cuePoints);\n      }\n    },\n    directives: [ɵngcc2.NgForOf],\n    styles: [\"\\n      vg-scrub-bar-cue-points {\\n        display: flex;\\n        width: 100%;\\n        height: 5px;\\n        pointer-events: none;\\n        position: absolute;\\n      }\\n      vg-scrub-bar-cue-points .cue-point-container .cue-point {\\n        position: absolute;\\n        height: 5px;\\n        background-color: rgba(255, 204, 0, 0.7);\\n      }\\n      vg-controls vg-scrub-bar-cue-points {\\n        position: absolute;\\n        top: calc(50% - 3px);\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgScrubBarCuePointsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet VgScrubBarCurrentTimeComponent = /*#__PURE__*/(() => {\n  class VgScrubBarCurrentTimeComponent {\n    constructor(ref, API) {\n      this.API = API;\n      this.vgSlider = false;\n      this.subscriptions = [];\n      this.elem = ref.nativeElement;\n    }\n\n    ngOnInit() {\n      if (this.API.isPlayerReady) {\n        this.onPlayerReady();\n      } else {\n        this.subscriptions.push(this.API.playerReadyEvent.subscribe(() => this.onPlayerReady()));\n      }\n    }\n\n    onPlayerReady() {\n      this.target = this.API.getMediaById(this.vgFor);\n    }\n\n    getPercentage() {\n      return this.target ? Math.round(this.target.time.current * 100 / this.target.time.total) + '%' : '0%';\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s.unsubscribe());\n    }\n\n  }\n\n  VgScrubBarCurrentTimeComponent.ɵfac = function VgScrubBarCurrentTimeComponent_Factory(t) {\n    return new (t || VgScrubBarCurrentTimeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.VgApiService));\n  };\n\n  VgScrubBarCurrentTimeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: VgScrubBarCurrentTimeComponent,\n    selectors: [[\"vg-scrub-bar-current-time\"]],\n    inputs: {\n      vgSlider: \"vgSlider\",\n      vgFor: \"vgFor\"\n    },\n    decls: 2,\n    vars: 3,\n    consts: [[1, \"background\"], [\"class\", \"slider\", 4, \"ngIf\"], [1, \"slider\"]],\n    template: function VgScrubBarCurrentTimeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", 0);\n        ɵngcc0.ɵɵtemplate(1, VgScrubBarCurrentTimeComponent_span_1_Template, 1, 0, \"span\", 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"width\", ctx.getPercentage());\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.vgSlider);\n      }\n    },\n    directives: [ɵngcc2.NgIf],\n    styles: [\"\\n      vg-scrub-bar-current-time {\\n        display: flex;\\n        width: 100%;\\n        height: 5px;\\n        pointer-events: none;\\n        position: absolute;\\n      }\\n      vg-scrub-bar-current-time .background {\\n        background-color: white;\\n      }\\n      vg-controls vg-scrub-bar-current-time {\\n        position: absolute;\\n        top: calc(50% - 3px);\\n        -webkit-border-radius: 2px;\\n        -moz-border-radius: 2px;\\n        border-radius: 2px;\\n      }\\n      vg-controls vg-scrub-bar-current-time .background {\\n        border: 1px solid white;\\n        -webkit-border-radius: 2px;\\n        -moz-border-radius: 2px;\\n        border-radius: 2px;\\n      }\\n      vg-scrub-bar-current-time .slider {\\n        background: white;\\n        height: 15px;\\n        width: 15px;\\n        border-radius: 50%;\\n        box-shadow: 0px 0px 10px black;\\n        margin-top: -5px;\\n        margin-left: -10px;\\n      }\\n    \"],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return VgScrubBarCurrentTimeComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst components = [VgControlsComponent, VgVolumeComponent, VgTrackSelectorComponent, VgTimeDisplayComponent, VgScrubBarComponent, VgQualitySelectorComponent, VgPlaybackButtonComponent, VgPlayPauseComponent, VgMuteComponent, VgFullscreenComponent, VgUtcPipe, VgScrubBarBufferingTimeComponent, VgScrubBarCuePointsComponent, VgScrubBarCurrentTimeComponent];\nlet VgControlsModule = /*#__PURE__*/(() => {\n  class VgControlsModule {}\n\n  VgControlsModule.ɵfac = function VgControlsModule_Factory(t) {\n    return new (t || VgControlsModule)();\n  };\n\n  VgControlsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: VgControlsModule\n  });\n  VgControlsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, VgCoreModule]]\n  });\n  return VgControlsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(VgControlsModule, {\n    declarations: function () {\n      return [VgControlsComponent, VgVolumeComponent, VgTrackSelectorComponent, VgTimeDisplayComponent, VgScrubBarComponent, VgQualitySelectorComponent, VgPlaybackButtonComponent, VgPlayPauseComponent, VgMuteComponent, VgFullscreenComponent, VgUtcPipe, VgScrubBarBufferingTimeComponent, VgScrubBarCuePointsComponent, VgScrubBarCurrentTimeComponent];\n    },\n    imports: function () {\n      return [CommonModule, VgCoreModule];\n    },\n    exports: function () {\n      return [VgControlsComponent, VgVolumeComponent, VgTrackSelectorComponent, VgTimeDisplayComponent, VgScrubBarComponent, VgQualitySelectorComponent, VgPlaybackButtonComponent, VgPlayPauseComponent, VgMuteComponent, VgFullscreenComponent, VgUtcPipe, VgScrubBarBufferingTimeComponent, VgScrubBarCuePointsComponent, VgScrubBarCurrentTimeComponent];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { VgControlsComponent, VgControlsModule, VgFullscreenComponent, VgMuteComponent, VgPlayPauseComponent, VgPlaybackButtonComponent, VgQualitySelectorComponent, VgScrubBarBufferingTimeComponent, VgScrubBarComponent, VgScrubBarCuePointsComponent, VgScrubBarCurrentTimeComponent, VgTimeDisplayComponent, VgTrackSelectorComponent, VgUtcPipe, VgVolumeComponent }; //# sourceMappingURL=videogular-ngx-videogular-controls.js.map","map":null,"metadata":{},"sourceType":"module"}